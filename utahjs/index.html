<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Behavioral driven development and the future</title>

    <meta name="description" content="A chronological tale of how automated testing has evolved over time.">
    <meta name="author" content="Todd Wolfson">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/default.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">

        <section>
          <h1>Behavioral driven development and the future</h1>
          <h3>The evolution of Automated Testing</h3>
          <p>
            <small>Created by <a href="http://twolfson.com/">Todd Wolfson</a> / <a href="http://twitter.com/twolfsn">@twolfsn</a> / <a href="http://github.com/twolfson">github/twolfson</a></small>
          </p>
          <p>
            <small><a href="http://wolfsn.com/utahjs.html">http://wolfsn.com/utahjs.html</a></small>
<!--             <small><a href="http://twolfson.github.io/behavioral-driven-development-and-the-future-presentation/utahjs/index.html">http://twolfson.github.io/behavioral-driven-development-and-the-future-presentation/utahjs/index.html</a></small>
 -->          </p>
        </section>

        <section>
          <h2>Live coding</h2>
          <h3>BDD Example</h3>

          <aside class="notes">
            Backup can be found <a href="code/backups/intro">here</a>.
          </aside>
        </section>

        <section>
          <section>
            <h2>Why are tests important?</h2>
            <blockquote>Why do cars have brakes?</blockquote>

            <aside class="notes">
              Take a few moments to let them think of answers.
            </aside>
          </section>
          <section>
            <h2>Why are tests important?</h2>
            <blockquote>Why do cars have brakes?</blockquote>
            <blockquote>So you can drive faster.</blockquote>
            <p>- <a href="http://jonjagger.blogspot.ie/2011/07/why-do-cars-have-brakes.html">Kevlin Henney</a></p>

            <aside class="notes">
               <p>Reduce time spent time spent cross-checking.</p>
               <p>Spend more time developing.</p>
               <p>Larger steps in iterations.</p>
               <p>Gain luxuries like throwing modules away.</p>
            </aside>
          </section>
        </section>

        <section>
          <section>
            <h2>Absolving confusion</h2>
            <h3>Time to unlearn misconceptions</h3>
          </section>
          <section>
            <h2>TDD/BDD</h2>
            <ul>
              <li>Methodologies for automated verification of expected functionality.</li>
              <li>Manual testing is <strong>not</strong> automated and therefore cannot be considered TDD/BDD.</li>
              <li>Differences are in the format (e.g. JSON, YAML, XML).</li>
            </ul>
          </section>
          <section>
            <h2>Test-first vs test-later approach</h2>
            <h3>It's all about the situation</h3>
            <ul>
              <li>Neither TDD nor BDD state that tests must be written first.</lI>
              <br/>
              <li>
                <p>In some situations, test-first is appropriate.</p>
                <ul><li>e.g. You have solidified the API</li></ul>
              </li>
              <br/>
              <li>
                <p>In other situations, test-later is appropriate.</p>
                <ul><li>e.g. You have the idea but not the specifics</li></ul>
              </li>
            </ul>
            <aside class="notes">
              <p>If you have not tried out the variants, it is a great learning experience.</p>
              <p>You might also find that writing your tests as a specification is what you need to smooth edges.</p>
            </aside>
          </section>
          <section>
            <h2>100% code coverage is not required</h2>
            <h3>Scenario strikes again</h3>
            <ul>
              <li>Code coverage has very little to do with TDD/BDD.</li>
              <br/>
              <li>
                <p>In some situations, 100% code coverage is appropriate.</p>
                <ul>
                    <li>e.g. You have very little fat</li>
                    <li>OR guaranteed specification will never change.</li>
                </ul>
              </li>
              <br/>
              <li>
                <p>In other situations, lower coverage is appropriate.</p>
                <ul>
                  <li>e.g. You are in the early stages of development</li>
                  <li>OR creating experimental features.</li>
                </ul>
              </li>
            </ul>
            <aside class="notes">
              <p>To bring this back to the brakes analogy, if it takes you longer to build the brakes than iterate on the car, then it might not be worth it. Especially if you are going to throw away the brakes in a bit for a re-factor.
              <p>Once again, try out the variations and learn.</p>
              <p>Personal note: In the node.js world, if I begin testing internals, I consider it a smell and abstract those internals into another module.</p>
            </aside>
          </section>
          <section>
            <h2>Implementation vs Methodology</h2>
            <ul>
              <li>
                Once again, TDD/BDD are about a format of tests and using them to move faster.
              </li>
              <br/>
              <li>
                PhantomJS is a testing harness for manipulating a browser.
              </li>
              <br/>
              <li>
                CasperJS is a combination of testing framework (TDD) and harness.
              </li>
              <br/>
              <li>
                Selenium is a combination of testing framework (TDD), runner, and harness.
              </li>
            </ul>
          </section>
          <section>
            <h2>&lt;/rant&gt;</h2>
          </section>
        </section>

        <section>
          <section>
            <h2>Before automation</h2>
          </section>
          <section>
            <h2>Manual testing</h2>
            <p><img alt="IBM logo" src="img/IBM_logo.jpg"/></p>
            <ul>
              <li>Manually cross-check results</li>
              <li>Have people poke at program until it breaks</li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h2>Birth of TDD</h2>
          </section>
          <section>
            <h2>SUnit (1994)</h2>
            <p><img alt="Kent Beck" src="img/xq10bqclqpsezgerjxhi.jpeg"/></p>
            <ul>
              <li>Kent Beck working mainly in Smalltalk.</li>
              <li>Tried out a few experiments and not quite settled.</li>
              <li>On a consulting gig, converted latest &ldquo;workspace&rdquo; concept into classical concept.</li>
            </ul>
          </section>
          <section>
            <h2>SUnit (1994)</h2>
            <pre><code>
  Class: SetTestCase
      superclass: TestCase
      instance variables: empty full

  SetTestCase>>setUp
      empty := Set new.
      full := Set
          with: #abc
          with: 5

  SetTestCase>>testAdd
      empty add: 5.
      self should: [empty includes: 5]

  SetTestCase>>testRemove
      full remove: 5.
      self should: [full includes: #abc].
      self shouldnt: [full includes: 5]

  | suite |
  suite := TestSuite named: 'Set Tests'.
  suite addTestCase: (SetTestCase selector: #testAdd).
  suite addTestCase: (SetTestCase selector: #testRemove).
  ^suite
            </code></pre>
            <small>(Sorry about the scrolling)</small>
          </section>
          <section>
            <h2>JUnit (1995 - 2000)</h2>
            <p><img alt="JUnit logo" src="img/junit1.gif"/></p>
            <ul>
              <li>In 1995, Kent Beck and Erich Gamma invent JUnit on plane ride to OopsLa.</li>
              <li>In 2000, junit.org is registered and published to Sourceforge.</li>
            </ul>
            <aside class="notes">
              <p>More backstory</p>
              <p>Gamma knows Java and Beck wants to learn.</p>
              <p>Gamma is interested in Beck's work on SUnit.</p>
              <p>At end of plane ride, they have a functional, self-testing testing library.</p>
            </aside>
          </section>
          <section>
            <h2>JUnit (1995 - 2000)</h2>
            <pre><code>
  public class MoneyTest extends TestCase {
      private Money f12CHF;
      private Money f14CHF;
      private Money f28USD;

      protected void setUp() {
          f12CHF= new Money(12, "CHF");
          f14CHF= new Money(14, "CHF");
          f28USD= new Money(28, "USD");
      }
  }

  public void testSimpleAdd() {
      Money m12CHF= new Money(12, "CHF");
      Money m14CHF= new Money(14, "CHF");
      Money expected= new Money(26, "CHF");
      Money result= m12CHF.add(m14CHF);
      assert(expected.equals(result));
  }

  TestSuite suite= new TestSuite();
  suite.addTest(new MoneyTest("testSimpleAdd"));
  TestResult result= suite.run();
            </code></pre>
            <small>(Sorry about the scrolling)</small>
          </section>
        </section>

        <section>
          <section>
            <h2>Evolution into BDD</h2>
          </section>
          <section>
            <h2>Dan North (2006)</h2>
            <p><img alt="Dan North" src="img/dan-north-portrait-e1344962419273.jpg"/></p>
            <p> Wants to convert agile story template into scenarios<p>
            <blockquote>
              <p>As a [X]</p>
              <p>I want [Y]</p>
              <p>so that [Z]</p>
            </blockquote>
            <blockquote>
              <p>Given some initial context,</p>
              <p>When an event occurs,</p>
              <p>then ensure some outcomes.</p>
            </blockquote>

            <aside class="notes">
              For the record, things were happening between 2000 and 2006. Lots of books were being published and TDD was becoming more and more known.
            </aside>
          </section>
          <section>
            <h2>Dan North (2006)</h2>
            <p>Inside of blog posts, already outlining features and benefits. Even has the name BDD already.</p>
            <blockquote style="text-align: left; font-style: none;">
              <p><em>Given</em> the account is in credit</p>
              <p><em>And</em> the card is valid</p>
              <p><em>And</em> the dispenser contains cash</p>
              <p><em>When</em> the customer requests cash</p>
              <p><em>Then</em> ensure the account is debited</p>
              <p><em>And</em> ensure cash is dispensed</p>
              <p><em>And</em> ensure the card is returned</p>
            </blockquote>
          </section>
          <section>
            <h2>Dan North (2006)</h2>
            <p>Converted story template looks like</p>
            <pre><code>
  public class AccountIsInCredit implements Given {
      public void setup(World world) {
          ...
      }
  }
  public class CardIsValid implements Given {
      public void setup(World world) {
          ...
      }
  }
  public class CustomerRequestsCash implements Event {
      public void occurIn(World world) {
          ...
      }
  }
            </code></pre>
          </section>
          <section>
            <h2>jBehave (2006)</h2>
            <p><img alt="jBehave logo" src="img/jbehave-logo.png"/></p>
            <ul>
              <li>Published by Dan North and Chris Matts</li>
            </ul>
          </section>
          <section>
            <h2>jBehave (2006)</h2>
            <pre><code>
  public class TraderSteps {

      private Stock stock;

      @Given("a stock of symbol $symbol and a threshold of $threshold")
      public void aStock(String symbol, double threshold) {
          stock = new Stock(symbol, threshold);
      }

      @When("the stock is traded at $price")
      public void theStockIsTradedAt(double price) {
          stock.tradeAt(price);
      }

      @Then("the alert status should be $status")
      public void theAlertStatusShouldBe(String status) {
          ensureThat(stock.getStatus().name(), equalTo(status));
      }

  }
            </code></pre>
          </section>
          <section>
            <h2>RSpec (2006)</h2>
            <p><img alt="RSpec book image" src="img/achbd_xlargecover.jpg"/></p>
            <ul>
              <li>Published by Steven Baker</li>
            </ul>
          </section>
          <section>
            <h2>RSpec (2006)</h2>
            <p>Very indicative of current mocha implementation</p>
            <pre><code>
  describe Hash do
    before(:each) do
      @hash = Hash.new(:hello => 'world')
    end

    it "should return a blank instance" do
      Hash.new.should eql({})
    end

    it "should hash the correct information in a key" do
      @hash[:hello].should eql('world')
    end
  end
            </code></pre>
          </section>
          <section>
            <h2>Cucumber (2008)</h2>
            <p><img alt="Cucumber logo" src="img/cucumber-logo.png"/></p>
            <ul>
              <li>Released as a gem by Aslak Helles&oslash;y</li>
              <li>First framework to separate specification from implementation.</li>
              <li>Re-embraces Agile/XP story template</li>
            </ul>
          </section>
          <section>
            <h2>Cucumber (2008)</h2>
            <pre><code>
Feature: Addition
  In order to avoid silly mistakes
  As a math idiot
  I want to be told the sum of two numbers

  Scenario Outline: Add two numbers
    Given I have entered &lt;input_1&gt; into the calculator
    And I have entered &lt;input_2&gt; into the calculator
    When I press &lt;button&gt;
    Then the result should be &lt;output&gt; on the screen
            </code></pre>
            <pre><code>
Before do
  @calc = Calculator.new
end

Given /I have entered (\d+) into the calculator/ do |n|
  @calc.push n.to_i
end

When /I press (\w+)/ do |op|
  @result = @calc.send op
end

Then /the result should be (.*) on the screen/ do |result|
  @result.should == result.to_f
end
            </code></pre>
          </section>
          <section>
            <h2>Flat files (???)</h2>
            <ul>
              <li>Tests represented as input/output files</li>
              <br/>
              <li>Language agnostic since they require a framework to run with</li>
              <br/>
              <li>
                <p>In the words of substack:</p>
                <blockquote>
                  It's the universal interface. Standard in and standard out.
                </blockquote>
            </ul>
            <aside class="notes">
              I learned about this via @fat's talk from JSConf 2012.
            </aside>
          </section>
          <section>
            <h2>Flat files (???)</h2>
            <p>Mustache implements its files this way</p>
            <pre><code>
  // Test data
  {
    name: "Chris",
    value: 10000,
    taxed_value: 6000,
    in_ca: true
  }
            </code></pre>
            <pre><code>
  // Mustache template
  Hello {{name}}
  You have just won ${{value}}!
  {{#in_ca}}
  Well, ${{ taxed_value }}, after taxes.
  {{/in_ca}}
            </code></pre>
            <pre><code>
  // Expected output
  Hello Chris
  You have just won $10000!
  Well, $6000, after taxes.
            </code></pre>
          </section>
        </section>

        <section>
          <h2>Review + Break</h2>
          <p>There are 4 common formats for tests<p>
          <ul>
            <li>TDD - Functional 1:1 testing of features</li>
            <li>
              <p>BDD (Specification / Joint)</p>
              <ul>
                <li>Uses keywords Given, When, Then.</li>
                <li>1:1 testing per features.</li>
              </ul>
            </li>
            <li>
              <p>BDD (Behavioral)</p>
              <ul>
                <li>Keywords used are describe and it.</li>
                <li>Context nesting allows double-duty for methods.</li>
              </ul>
            </li>
            <li>
              <p>BDD (Specification / Separated)</p>
              <ul>
                <li>Creates 2 files (a story, an implementation).</li>
                <li>Keywords are Given, When, Then.</li>
                <li>Re-use of methods across tests.</li>
              </ul>
            </li>
          </ul>
        </section>

        <section>
          <section>
            <h2>Modern time. Modern space.</h2>
            <h3>var now = new Date();</h3>
          </section>
          <section>
            <h2>JUnit (circa 2012)</h2>
            <pre><code>
  public class MyClassTest {

    @BeforeClass
    public static void testSetup() {
    }

    @AfterClass
    public static void testCleanup() {
      // Teardown for data used by the unit tests
    }

    @Test(expected = IllegalArgumentException.class)
    public void testExceptionIsThrown() {
      MyClass tester = new MyClass();
      tester.multiply(1000, 5);
    }

    @Test
    public void testMultiply() {
      MyClass tester = new MyClass();
      assertEquals("10 x 5 must be 50", 50, tester.multiply(10, 5));
    }
  }
            </code></pre>
            <aside class="notes">
              For those of you reading at home, <a href="http://www.vogella.com/articles/JUnit/article.html">http://www.vogella.com/articles/JUnit/article.html</a>
            </aside>
          </section>
          <section>
            <h2>qunit</h2>
            <pre><code>
  test( "ok test", function() {
    ok( true, "true succeeds" );
    ok( "non-empty", "non-empty string succeeds" );
    ok( false, "false fails" );
    ok( 0, "0 fails" );
    ok( NaN, "NaN fails" );
    ok( "", "empty string fails" );
    ok( null, "null fails" );
    ok( undefined, "undefined fails" );
  });
            </code></pre>
          </section>
          <section>
            <h2>nodeunit</h2>
            <pre><code>
  module.exports = {
      setUp: function (callback) {
          this.foo = 'bar';
          callback();
      },
      tearDown: function (callback) {
          // clean up
          callback();
      },
      test1: function (test) {
          test.equals(this.foo, 'bar');
          test.done();
      }
  };
            </code></pre>
          </section>
          <section>
            <h2>Expresso</h2>
            <pre><code>
  module.exports = {
      'test String#length': function(beforeExit, assert) {
        assert.equal(6, 'foobar'.length);
      }
  };
            </code></pre>
          </section>
          <section>
            <h2>tape</h2>
            <pre><code>
  test('timing test', function (t) {
      t.plan(2);

      t.equal(typeof Date.now, 'function');
      var start = Date.now();

      setTimeout(function () {
          t.equal(Date.now() - start, 100);
      }, 100);
  });
            </code></pre>
          </section>
          <section>
            <h2>Jasmine</h2>
            <p>Good for synchronous. Horrible for asynchronous.</p>
            <pre><code>
  describe("A suite is just a function", function() {
    var a;

    it("and so is a spec", function() {
      a = true;

      expect(a).toBe(true);
    });
  });
            </code></pre>
            <pre><code>
  describe("Asynchronous specs", function() {
    var value, flag;

    it("should support async execution [...]", function() {

      runs(function() {
        flag = false;
        value = 0;

        setTimeout(function() {
          flag = true;
        }, 500);
      });

      waitsFor(function() {
        value++;
        return flag;
      }, "The Value should be incremented", 750);

      runs(function() {
        expect(value).toBeGreaterThan(0);
      });
    });
  });
            </code></pre>
          </section>
          <section>
            <h2>Cucumber.js</h2>
            <pre><code>
  Feature: Example feature
    As a user of cucumber.js
    I want to have documentation on cucumber
    So that I can concentrate on building awesome applications

    Scenario: Reading documentation
      Given I am on the Cucumber.js Github repository
      When I go to the README file
      Then I should see "Usage" as the page title
            </code></pre>
            <pre><code>
  module.exports = function () {
    this.World = require("../support/world.js").World; // overwrite default World constructor

    this.Given(/^I am on the Cucumber.js Github repository$/, function(callback) {
      // Express the regexp above with the code you wish you had.
      // `this` is set to a new this.World instance.
      // i.e. you may use this.browser to execute the step:

      this.visit('http://github.com/cucumber/cucumber-js', callback);

      // The callback is passed to visit() so that when the job's finished, the next step can
      // be executed by Cucumber.
    });

    this.When(/^I go to the README file$/, function(callback) {
      // Express the regexp above with the code you wish you had. Call callback() at the end
      // of the step, or callback.pending() if the step is not yet implemented:

      callback.pending();
    });

    this.Then(/^I should see "(.*)" as the page title$/, function(title, callback) {
      // matching groups are passed as parameters to the step definition

      if (!this.isOnPageWithTitle(title))
        // You can make steps fail by calling the `fail()` function on the callback:
        callback.fail(new Error("Expected to be on page with title " + title));
      else
        callback();
    });
  };
            </code></pre>
          </section>
          <section>
            <h2>vows</h2>
            <p>Designed for async/parallel tests in node.</p>
            <pre><code>
  vows.describe('The Good Things').addBatch({
      'A banana': {
          topic: new(Banana),

          'when peeled *synchronously*': {
              topic: function (banana) {
                  return banana.peelSync();
              },
              'returns a `PeeledBanana`': function (result) {
                  assert.instanceOf (result, PeeledBanana);
              }
          },
          'when peeled *asynchronously*': {
              topic: function (banana) {
                  banana.peel(this.callback);
              },
              'results in a `PeeledBanana`': function (err, result) {
                  assert.instanceOf (result, PeeledBanana);
              }
          }
      }
  }).export(module); // Export the Suite
            </code></pre>
          </section>
          <section>
            <h2>mocha</h2>
            <pre><code>
    describe('Array', function(){
      before(function(){
        // ...
      });

      describe('#indexOf()', function(){
        it('should return -1 when not present', function(){
          [1,2,3].indexOf(4).should.equal(-1);
        });
      });
    });
            </code></pre>
            <pre><code>
  suite('Array', function(){
    setup(function(){
      // ...
    });

    suite('#indexOf()', function(){
      test('should return -1 when not present', function(){
        assert.equal(-1, [1,2,3].indexOf(4));
      });
    });
  });
            </code></pre>
          </section>
          <section>
            <h2>intern</h2>
            <pre><code>
define([
  'intern!bdd',
  'intern/chai!expect',
  '../Request'
], function (bdd, expect, Request) {
  with (bdd) {
    describe('demo', function () {
      var request,
        url = 'https://github.com/theintern/intern';

      // before the suite starts
      before(function () {
        request = new Request();
      });

      // before each test executes
      beforeEach(function () {
        request.reset();
      });

      // after the suite is done
      after(function () {
        request.cleanup();
      });

      // multiple methods can be registered and will be executed in order of registration
      after(function () {
        if (!request.cleaned) {
          throw new Error('Request should have been cleaned up after suite execution.');
        }

        // these methods can be made asynchronous as well by returning a promise
      });

      // asynchronous test for Promises/A-based interfaces
      it('should demonstrate a Promises/A-based asynchronous test', function () {
        // `getUrl` returns a promise
        return request.getUrl(url).then(function (result) {
          expect(result.url).to.equal(url);
          expect(result.data.indexOf('next-generation') > -1).to.be.true;
        });
      });

      // asynchronous test for callback-based interfaces
      it('should demonstrate a callback-based asynchronous test', function () {
        // test will time out after 1 second
        var dfd = this.async(1000);

        // dfd.callback resolves the promise as long as no errors are thrown from within the callback function
        request.getUrlCallback(url, dfd.callback(function () {
          expect(result.url).to.equal(url);
          expect(result.data.indexOf('next-generation') > -1).to.be.true;
        });

        // no need to return the promise; calling `async` makes the test async
      });

      // nested suites work too
      describe('xhr', function () {
        // synchronous test
        it('should run a synchronous test', function () {
          expect(request.xhr).to.exist;
        });
      });
    });
  }
});
            </code></pre>
          </section>
        </section>

        <section>
          <section>
            <h2>Time to experiment</h2>
            <aside class="notes">
              I wrote this when I lacked knowledge of everything in this presentation except for vows, mocha, and seeing Gherkin but not understanding it. I wanted to hybridize them without constraints.
            </aside>
          </section>
          <section>
            <h2>doubleshot (2013)</h2>
            <ul>
              <li>Wanted slimmer tests and at-a-glance specifications.</li>
              <li>Loved vows syntax.</li>
              <li>Tried out a few things for cross-compiling vows into mocha but they failed (crossbones, sculptor).</li>
              <li>Discovered cool features upon writing it.</li>
            </ul>
          </section>
          <section>
            <h2>doubleshot (2013)</h2>
            <h3>Live code example</h3>
          </section>
        </section>

        <section>
          <h1>Behavioral driven development and the future</h1>
          <h3>The evolution of Automated Testing</h3>
          <p>
            <small>Created by <a href="http://twolfson.com/">Todd Wolfson</a> / <a href="http://twitter.com/twolfsn">@twolfsn</a> / <a href="http://github.com/twolfson">github/twolfson</a></small>
          </p>
          <p>
            <small><a href="http://wolfsn.com/utahjs.html">http://wolfsn.com/utahjs.html</a></small>
<!--             <small><a href="http://twolfson.github.io/behavioral-driven-development-and-the-future-presentation/utahjs/index.html">http://twolfson.github.io/behavioral-driven-development-and-the-future-presentation/utahjs/index.html</a></small>
 -->          </p>
          <aside class="notes">
            <p>Lastly, don't forget why cars have brakes.</p>
            <p>Thank you.</p>
          </aside>
        </section>

      </div>

    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.min.js"></script>

    <script>

      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
          // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
          // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });

    </script>

  </body>
</html>
